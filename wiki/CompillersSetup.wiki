#summary Сборка и настройка компилятора GCC

= Понятие "компилятор", или как отличить гуй от компилятора =

У многих формируется не верное представление о том, что же такое компилятор, часто путая среду разработки с программой, преобразующей исходный код в бинарный обьектник. Компиляторы, как правило, все консольные. Это предоставляет гибкие возможности к интеграции компиляторов в различные системы сборок или IDE. Можно выделить 3 компилятора, с которыми вам, возможно, прийдётся столкнутся при разработке эльфов для LG:

 * gcc
 * clang
 * iar

Расмотрим первый в списке компилятор - gcc. Абривиатура gcc расшифровывается как GNU Compilers Collection. Это открытый компилятор, с открытыми исходными кодами, равиваемый сообществом GNU. Практически во всех открытых проектах, компилятор gcc является стандартом-де-факто, поэтому использование данного компилятора даёт некий бонус, в виде возможности легче собрать какую-нибудь бибилиотеку, или портировать какую-нибудь функциональность на LG. Компилятор имеет богатую функциональность и поддерживает несколько из известных языков, но нам понадобятся только 2 языка - Си и С++. Компилято имеет современные техники оптимизации, в том числе и LTO - Link-time optimization(правда на данном этапе, она ещё не до конца реализована/отшлифована, поэтому с ней надо быть осторожней).


Второй на очереди компилятор - clang. Молодой компилятор, разрабатываемый компанией Apple с полностью открытым исходным кодом, совместимым на уровне комманд с gcc. Этот компилятор использует наработки проекта LLVM, в рамках которого разрабатывается "выскокоуровневый ассемблер", который может быть собран под конкретную архитектуру со специфичными для неё оптимизациями.


Последний из списка компилятор - iar. Комерческий компилятор, который использовался сообществом сименсоводов для сборки эльфов. Последняя вменяемая версия 4.4.2, так как в остальных версиях убрали поддержку сборки PIC кода, что является непозволительным для эльфов LG нуждающимся в позиционно-независимом коде.


= Что такое комманда(ключь, флаг) в консольных программах =

Ключи используются повсеместно, для указания программе, что именно от неё требуется. В нашем случаем, флагами компилятора, мы будем указывать, что, куда и как компилировать. К примеру, нам нада указать компилятору, под каким именем сохранить результат его работы, для этого существует ключ "-o"(от анг. output), указывающий, куда и под каким именем сохранить  исполняемый файл или объект.

$ arm-aebi-gcc main.c -o main.elf

С базовыми знаниями пожалуй закончим, приступим непосредственно к сборке/настройке компиляторов.

<br/>
= Сборка компилятора GCC =

В UNIX-подобных операционных системах это делается следующим образом:

 # Скачиваем последний релиз http://mirrors-us.seosue.com/gcc/releases/
 # Расспаковываем и собираем

<code language="bash">
$ mkdir build && cd build 
$ ../configure --target=arm-eabi --prefix=/usr --enable-interwork --enable-languages=c,c++ --enable-lto
$ make all-gcc -j3 
$ make install-gcc
</code>


Но для линковки готового исполняемого файла, нам ещё потребуется линкер - binutils. Сценарий практически тот-же:

 # Качаем http://ftp.gnu.org/gnu/binutils/
 # Расспаковываем и собираем

<code language="bash">
$ ./configure --prefix=/usr --target=arm-eabi --enable-interwork --enable-multilib --with-float=soft --disable-werror 
$ make -j3 
$ make install
</code>

= Дополнительные файлы для сборки =
Нам понадобятся библиотеки для сборки эльфов, а именно:

 * libscrt - библиотека отвечающая за иницализацию эльфа
 * libgcc - библиотека компилятора gcc
 * libc - портированная стандартная C бибилотека
 * libstdc++ - портированная стандарная библиотека C++(gnu stdc++)
 * libsupc++ - некоторые статические функции, нужные С++

А так-же нужны для линковки эльфов [http://code.google.com/p/lg-phone-develop/source/browse/trunk/gcc/elf-init-libs файлы] инициализации:
 * crt0.o
 * crtbegin.o
 * crtend.o
 * crti.o
 * crtn.o

Их нужно ложить в папку с компилятором:
 * unix: /usr/lib/gcc/arm-eabi/{версия компилятора}/
 * win(точно не знаю, не проверял): {папка куда установили}\lib\ 

<br/>
= Какие ключи использовать =
 Эти флаги должны использоватся всегда, если конечно вы не хотите, чтобы ваш эльф ронял телефон.

 == Для компилятора: ==

<code language="bash">
 $ arm-eabi-gcc -msoft-float -fshort-wchar -marm -mlittle-endian -mcpu=arm926ej-s -nostdlib -fno-exceptions -fdata-sections -ffunction-sections
</code>

 * -msoft-float        - режим софтовой обработки чисел с плавающей точкой
 * -fshort-wchar       - использовать 2 байта для мультибайтной строки wchar_t
 * -marm               - использовать только режим ARM(может быть ещё -thumb)
 * -mlittle-endian     - little-endian порядок байтов
 * -mcpu=arm926ej-s    - тип процессора arm926ej-s
 * -nostdlib           - не использовать стандартные бибилотеки(у нас они свои)
 * -fno-exceptions     - исключений у нас нет, поэтому скажем компилятору об этом
 * -fdata-sections     - перемещять в специальную секцию неиспользуемые переменные/данные, чтобы их можно было потом вырезать
 * -ffunction-sections - аналогично как с data-sections, только для функций


 == Для линкера: == 
 
<code language="bash">
 $ arm-eabi-ld -pie -gc-sections -zmax-page-size=1 -nostdlib -marmelf --defsym __ex=0
</code>

 * -pie              - position independent executable(для линковки бибилиотек указывать -shared)
 * -gc-sections      - вырезать не используемые переменные/функции
 * -zmax-page-size=1 - максимальный размер страницы - 1
 * -nostdlib         - не линковать билиотеки по умолчанию
 * -marmelf          - указать тип исполняемого файла как ARM-ELF
 * --defsym __ex=0   - специфичная для эльфпака опция, указывающая импорт cлужебной переменной __ex



 == Как собрать программу из консоли == 

Простой пример, показывающий принцип сборки. Примечательно, мы использум для линковки вместо arm-eabi-ld - arm-eabi-gcc, так как такой подход позволяет задействовать ряд функций, вроде LTO(для этого нужно явно укзать ключи)

<code language="bash">
$ export CFLAGS="-msoft-float -fshort-wchar -marm -mlittle-endian -mcpu=arm926ej-s -nostdlib -fno-exceptions -fdata-sections -ffunction-sections"
$ arm-eabi-gcc $CFLAGS -c main.c -O2 -omain.o
$ arm-eabi-gcc -Wl,-pie,-gc-sections,-zmax-page-size=1,-nostdlib,-marmelf,--defsym,__ex=0 -lscrt main.o -oMyMegaProgramm.elf
</code>

Получаем исполняемый файл, готовый к запуску. Но чтобы облегчить себе жизнь, можно установить среду(IDE) и доверить это дело ей.
Читайте вики о настройке QtCreator или CodeBlocks IDE.

